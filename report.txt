Abhinav Barnawal (2020CS50415) & Kushagra Rode (2020CS10354)

Part A: Estimation

For implementing the probabilistic tracker, we have made use of particle filtering. So, broadly, the particle filter working has been divided into sections, one for cases when the car is not parked and the other for when it is parked. So, firstly if the car is not parked, we start by creating some initial weights, which are decided by the current belief for each grid cell. Next, using these weights, we sample the particles. The number of particles equals the product of the number of rows and columns. Next, we use the transition probabilities to account for the motion of the cars. If a transition is absent in the probability table, we assume it to be 0. We remove this particle if all possible transitions have a probability of zero. We check for each of the eight directions the car can move into and then account for their probabilities and use them to estimate the position of this particle at the next instant. After this, we calculate the estimated distance of the position of this particle from the AutoCar's position. Then we sample the weight for this particle from the normal distribution with standard deviation as Const.SONAR_STD. Now, for the case when the car is parked, we don't use the transition probabilities and also use the current set of particles rather than the current belief and then assign weights according to the normal distribution. After this, we resample the particles according to the weights set above and then set the belief.

Part B: Planning

The core idea of implementing the autonomous driver is to find the shortest path to the goal using Dijkstra's algorithm. Now we'll explain the various functions which we have used to improve our planning strategy:-
1) createWorldGraph - For applying Dijkstra's algorithm, we need to have a graphical representation of the complete grid. We have created a weighted directed graph for the same. Each grid cell, apart from the ones which are blocks, is a vertex in our graph. The cells around each block and the cells around the boundary of the grid are included in a list called padded blocks. Each vertex v has edges to its four adjacent vertices. All edges between v and its neighbours are assigned a weight of 1.
2) modifyWorldGraph - This function considers the belief of the Std Cars provided to us. In this function, we will modify the edge weights of the incoming edges of a cell according to the belief present in it. Since the observation is noisy, we need to consider this error and adjust the beliefs of the nearby cells by some amount. So basically, our idea is to penalise the car from going into cells with higher beliefs.
3) getShortestPathUsingDijkstra - This takes the current position, the goal position and the belief as input and returns the next cell, which is present on the shortest path to the goal. So, firstly we call the modifyWorldGraph to get a new belief. Next, we run Dijkstra's algorithm to obtain the shortest path. After finding the path, we get the next node on the shortest path to our goal. Now we want to take into account the congestion of the cars that might be present (this is done by taking into account the belief obtained after calling the modifyWorldGraph function) as well as the case when the auto car wants to make a sharp turn(this is by finding the wheel angle). For the same we make our car wait for a given amount of time which varies with the degree of congestion found by the belief. We allow the car to move forward if there is little or no congestion. Also, we consider the car's length to provide clearance when driving close to other cars or blocks.
4) updateBeliefOfOtherCars - This function accounts for some forecast of the std cars by using their transition probabilities. This is useful to prevent the auto car from going into a collision course with another std car.

So, in the function getNextGoalPos, we first call the updateBeliefOfOtherCars function to get the updated belief. Then we obtain the next node from getShortestPathUsingDijkstra. If the congestion is high, we wait; otherwise, we return to the next node and move forward.