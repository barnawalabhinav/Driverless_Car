Abhinav Barnawal (2020CS50415) & Kushagra Rode (2020CS10354)

Part A: Estimation

For implementing the probabilistic tracker, we have made use of particle filtering. So, broadly the particle filter working has been divided into sections, one is for cases when the car is not parked, and the other is when it is parked. So, firstly if the car is not parked, we start by creating some initial weights, which are decided by the current belief for each grid cell. Next, using these weights, we sample the particles. The number of particles equals the product of the number of rows and columns. Next, we use the transition probabilities to account for the motion of the cars. If a transition is absent in the probability table, we assume it to be 0. If all possible transitions have a probability of zero, we remove this particle. We check for each of the 8 directions the car can move into and then account for their probabilities and use them to estimate the position of this particle at the next instant. After this, we calculate the estimated distance of the position of this particle from the AutoCar's position. Then we sample the weight for this particle from the normal distribution with standard deviation as Const.SONAR_STD. Now, for the case when the car is parked, we don't make use of the transition probabilities and also make use of the current set of particles rather than the current belief and then assign weights according to the normal distribution. After this, we resample the particles according to the weights set above and then set the belief.

Part B: Planning

To implement the autonomous driver, the core idea is to find the shortest path to the goal using the Dijkstra's algorithm. ONow we'll explain the various functions which we have used to improve our planning strategy :-
1) createWorldGraph - For applying dijkstra's algorithm, we need to have a graphical representation of the complete grid. We have created a weighted directed graph for the same. Each grid cell apart from the ones which are blocks is a vertex in our graph. The cells around each of the blocks and the cells around the boundary of the grid are included in a list called padded blocks. Each vertex v has edges to it's 4 adjacent vertices. All edges between v and it's neighbours are assigned a weight of 1.
2) modifyWorldGraph - This function takes into account the belief of the Std Cars provided to us. In this function, we will modify the edge weights of the incoming edges of a cell according to the belief present in it. Since the observation is noisy we need to take into account this error and adjust the beliefs of the nearby cells by some amount. So basically our idea is to penalize the car from going into cells with higher beliefs.
3) getShortestPathUsingDijkstra - This takes the current position, the goal position and the belief as input and returns the next cell which is present on the shortest path to the goal. So, firstly we call the modifyWorldGraph to get the new belief. Next we run the dijkstra's algorithm to obtain the shortest path. After finding the path, we get the next node on the shortest path to our goal. Now we actually want to take into account the congestion the cars that might be present(this done by taking into account the belief obtained after calling the modifyWorldGraph function) as well as the case when the auto car wants to make a sharp turn(this is by finding the wheelAngle). For the same we make our car wait for a given amount of time which varies with the degree of congestion found by the belief. If there is little or no congestion, we allow the car to move forward. Also, we take into account the length of the car so as to provide clearance when moving close to other cars or blocks.
4) updateBeliefOfOtherCars - This function is used to account for some forecast of the std cars by making use of their transition probabilities. This is useful to prevent the auto car from going into a collision course with another std car.

So, in the function getNextGoalPos, we firstly call the updateBeliefOfOtherCars function to get the updated belief. Then we obtain the next node from getShortestPathUsingDijkstra. If the congestion is high we wait otherwise we return the next node and move forward.